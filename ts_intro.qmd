# 什麼是時間序列

時間序列是一筆序列資料，換言之，資料間存在順序關係，而這些序列的排序是按照時間排序的，因此稱為時間序列資料

```{python}
import plotly.graph_objects as go
import numpy as np
```

## Time Series v.s. Cross Sectional

最常被混淆的概念就是時間序列 (time series) 與橫斷面 (cross sectional) 資料，他們的差別如下


| 差別 | Time Series | Cross Sectional |
|---------|:-----|:------|
| 定義      | 固定時間點蒐集的序列資料   | 同一時間點不同個體的資料 |
| 範例       | 2000/01/01 到 2020/01/01 台積電每日股票的收盤價    | 2000/01/01 台灣前 50 大上市公司的股價 |

: Time Series v.s. Cross Sectional

## 為什麼我們需要時間序列模型

接續前文的定義，假設我們想調查 2000/01/01 到 2020/01/01 台積電每日股票的收盤價，每天收盤價對於我們而言都是一個隨機變數，而且我們不能保證這些隨機變數屬於同一個分配，因為他們來自不同時間點，換句話說，每天的收盤價是從不同母體抽樣出來的，而且只有**一個樣本點**，當只有一個樣本點時，就不能採用過往我們熟悉的統計工具解決問題，因此，我們**勢必要假設資料與資料之間存在某種的關係，而這個關係是會隨著時間變化的**

## 數學上的時間序列

我們假設隨機變數 

- $\bf{U}_t, t\in \{1,\cdots,T\}$ 

表示時間序列的隨機變數。我們可以把 $U_t$ 看做是隨著時間變化的變數，例如每日股價，每年人口增長率等等，總結來說 $U_t$ 包含兩個面向

- 隨機變數 $U \to$ 表示隨著時間變化我們感興趣的指標
- 時間區間 $t \to$ 表示時間的過程，通常為等量區間，例如每天、每年

至此，我們已經大致了解時間序列是什麼樣的資料了，但是，事實上並不是這麼簡單，我們常常看到的時間序列表現形式通常會長的像下面這樣

$\bf U_t=T_t+S_t+C_t+R_t$

其中

- $T_t:$ 趨勢效應 (Trend component)
- $S_t:$ 季節效應 (Seasonal component)
- $C_t:$ 循環效應 (Cyclical component)
- $R_t:$ 隨機效應 (Random component)

時間序列資料大概可以分解成上面的四個主要部分，接下來我們來一一解析他們

### 趨勢效應

我們常常說一檔股票有上升趨勢或下降趨勢，其實很容易理解，趨勢表示長期時間來看，資料平移變化的方向。例如在下面的例子中，我們調查一般民眾獲取新聞的方式，可以很明顯看到

- Downward Trend: Television、Newspaper
- No Trend: Radio
- Upward Trand: Internet

表示隨著時間發展，使用網路獲取信息的人們越來越多了

```{python}
#| code-fold: true
title = 'Main Source for News'
labels = ['Television', 'Newspaper', 'Internet', 'Radio']
colors = ['rgb(67,67,67)', 'rgb(115,115,115)', 'rgb(49,130,189)', 'rgb(189,189,189)']

mode_size = [8, 8, 12, 8]
line_size = [2, 2, 4, 2]

x_data = np.vstack((np.arange(2001, 2014),)*4)

y_data = np.array([
    [74, 82, 80, 74, 73, 72, 74, 70, 70, 66, 66, 69],
    [45, 42, 50, 46, 36, 36, 34, 35, 32, 31, 31, 28],
    [13, 14, 20, 24, 20, 24, 24, 40, 35, 41, 43, 50],
    [18, 21, 18, 21, 16, 14, 13, 18, 17, 16, 19, 23],
])

fig = go.Figure()

for i in range(0, 4):
    fig.add_trace(go.Scatter(x=x_data[i], y=y_data[i], mode='lines',
        name=labels[i],
        line=dict(color=colors[i], width=line_size[i]),
        connectgaps=True,
    ))

    # endpoints
    fig.add_trace(go.Scatter(
        x=[x_data[i][0], x_data[i][-1]],
        y=[y_data[i][0], y_data[i][-1]],
        mode='markers',
        marker=dict(color=colors[i], size=mode_size[i])
    ))

fig.update_layout(
    xaxis=dict(
        showline=True,
        showgrid=False,
        showticklabels=True,
        linecolor='rgb(204, 204, 204)',
        linewidth=2,
        ticks='outside',
        tickfont=dict(
            family='Arial',
            size=12,
            color='rgb(82, 82, 82)',
        ),
    ),
    yaxis=dict(
        showgrid=False,
        zeroline=False,
        showline=False,
        showticklabels=False,
    ),
    autosize=False,
    margin=dict(
        autoexpand=False,
        l=100,
        r=20,
        t=110,
    ),
    showlegend=False,
    plot_bgcolor='white'
)

annotations = []

# Adding labels
for y_trace, label, color in zip(y_data, labels, colors):
    # labeling the left_side of the plot
    annotations.append(dict(xref='paper', x=0.05, y=y_trace[0],
                                  xanchor='right', yanchor='middle',
                                  text=label + ' {}%'.format(y_trace[0]),
                                  font=dict(family='Arial',
                                            size=16),
                                  showarrow=False))
    # labeling the right_side of the plot
    annotations.append(dict(xref='paper', x=0.95, y=y_trace[11],
                                  xanchor='left', yanchor='middle',
                                  text='{}%'.format(y_trace[11]),
                                  font=dict(family='Arial',
                                            size=16),
                                  showarrow=False))
# Title
annotations.append(dict(xref='paper', yref='paper', x=0.0, y=1.05,
                              xanchor='left', yanchor='bottom',
                              text='Main Source for News',
                              font=dict(family='Arial',
                                        size=30,
                                        color='rgb(37,37,37)'),
                              showarrow=False))
# Source
annotations.append(dict(xref='paper', yref='paper', x=0.5, y=-0.1,
                              xanchor='center', yanchor='top',
                              text='Source: PewResearch Center & ' +
                                   'Storytelling with data',
                              font=dict(family='Arial',
                                        size=12,
                                        color='rgb(150,150,150)'),
                              showarrow=False))

fig.update_layout(annotations=annotations)

fig.show()
```

### 季節效應與循環效應

季節效應與週期效應都是週期性產生的影響，但大家較易於混淆這兩者的概念，簡單來說，如果頻率變化固定且已知，則為季節性，例如氣溫的變化會隨著四季更迭，降雨量也會根據不同月份而不同，若頻率變化不固定，則為循環性

例如下面這個範例有週期性的特徵，且每個同樣的時間區間就會有相同的頻率，則為季節性

```{python}
#| code-fold: true
title = 'Seasonal Effect'

x_data = np.linspace(-10, 10, 100)

y_data = np.array(
    np.sin(x_data) + np.random.normal(size=x_data.shape) * 0.25
)

fig = go.Figure()

fig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

下面這張圖雖然具有週期性特徵，但是其頻率不固定，雖然固定的一個時間區間會產生高峰，但是高峰會隨著時間越來越高


```{python}
#| code-fold: true
title = 'Cyclical Effect'

x_data = np.linspace(-10, 10, 100)

y_data = np.array(
    np.sin(x_data)*np.exp(x_data/10) + np.random.normal(size=x_data.shape) * 0.25
)

fig = go.Figure()

fig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

### 隨機效應

最後一個為隨機效應，通常表示資料的隨機性，也最好理解，因為她就是隨著時間產生的一個隨機效應

例如下面這張圖，雖然我們是使用 sin 函數去生成的，但是我們給他加上一個常態分配的隨機抽樣，整體就變得不是那麼明顯了

```{python}
#| code-fold: true
title = 'Seasonal Effect'

x_data = np.linspace(-10, 10, 100)

y_data = np.array(
    np.sin(x_data) + np.random.normal(size=x_data.shape) * 1
)

fig = go.Figure()

fig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

## 我怎麼知道資料是否適合時間序列分析

如何知道資料屬於哪一種效應是一種非常仰賴經驗判斷的方法，例如從下面這張圖來說，我們幾乎無法斷定資料是否存在某種效應，最多也只能說是沒有一個明顯的趨勢效應

```{python}
#| code-fold: true
title = 'Cyclical Effect'

x_data = np.linspace(-10, 10, 1000)

y_data = np.array(
    np.sin(x_data)*np.exp(x_data/100)/10 + np.random.normal(size=x_data.shape)
)

fig = go.Figure()

fig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

從最初到現在，我們也可以看出，我們對於資料存在著多種假設，我們基於這些假設去判斷資料最可能的模型，然而，當有一些模型假設錯誤時，很長造成模型擬合效果不彰，因此，對於資料**使用時間序列模型是最後的手段**，最好還是先嘗試其他模型

讓我們回到上面的那筆資料，當我們暫時忽略時間的效應，按照資料的隨機變數畫出下面的分布圖時，我們會發現它其實很像是一個常態分配，但好像又比常態分配寬一點，這讓我們懷疑到底時間有沒有存在影響，又或是他的影響到底多大。所以接下來，我們來講講怎麼看待這件事情

```{python}
import plotly.figure_factory as ff
import numpy as np

hist_data = [y_data]

group_labels = ['Data (no T)']
colors = ['#A56CC1']

# Create distplot with curve_type set to 'normal'
fig = ff.create_distplot(hist_data, group_labels, colors=colors,
                         bin_size=.2, show_rug=False)

# Add title
fig.update_layout(title_text='Hist and Curve Plot')
fig.show()
```

## 平穩性 Stationary

在時間序列分析中，我們必須對於資料有簡單又合理的假設，才可以容易建立模型，平穩性就是其中一個，簡單來說，平穩性表示你的資料還是有時間效應，但是這個效應影響不大，其主要分為兩種

### 弱平穩 Weak stationary

我們先來看看弱平穩的數學定義

若 $\{Z_t\}$ 被稱為弱 (second-order or covariance stationary) 平穩過程，則

- $\mu(t)=C:$ $\mu$ 與時間無關
- $\gamma(t, t-k)=\gamma(0, k):$ 共變異函數只與滯後 (lag) 有關

簡單而言，平均變化與時間無關，且變數之間的相關性只在滯後上有關係。例如，白噪聲就是一個弱平穩過程，因為白噪聲 $\sim \mathcal{N}(0,\sigma^2I)$。隨機遊走是非平穩的，例如下面我們建立一個例子

$$
X_t = X_{t-1} + \epsilon
$$

其中 $\epsilon$ 為白噪聲，則我們有

- $\mathbb{E}(X_t)=\mathbb{E}(X_{t-1})$
- $\mbox{Var}(X_t)=t\sigma^2$

```{python}
#| code-fold: true
title = 'Seasonal Effect'

T = 1000
walks = []

loc = 0
for i in range(T):
    loc += + np.random.normal(0,1)
    walks.append(loc)
walks = np.array(walks)

fig = go.Figure()

fig.add_trace(go.Scatter(x=list(range(T)), y=walks, mode='lines',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

因為變異數與時間有關，因此不是弱平穩，但是當我們去檢驗差分 $D_t=X_t-X_{t-1}=ㄔ$ 的分布時，他又是弱平穩的，因為

- $\mathbb{E}(D_t)=0$
- $\mbox{Var}(X_t)=\sigma^2$

下面我們畫圖來值觀感受一下差分的魅力

```{python}
#| code-fold: true
title = 'Seasonal Effect'

D = walks[1:] - walks[:-1]

fig = go.Figure()

fig.add_trace(go.Scatter(x=list(range(T-1)), y=D, mode='lines',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

是不是完全變成白噪聲了啊，所以我們會發現，很多時間序列的方法都使用差分的技巧來將原先的資料分解到平穩狀態

### 強平穩 Strict stationary

接著，我們介紹另外一種平穩過程，強平穩，他的數學定義如下

若 $\{Z_t\}$ 被稱為強平穩過程，則

$Z_{t_1}, Z_{t_2}, \cdots, Z_{t_n}$ 的聯合分配與 $Z_{t_1-k}, Z_{t_2-k}, \cdots, Z_{t_n-k}$ 的聯合分配相同

講白話一點，就是我們選一個時間序列的某一段切下去，跟前面的一段時間完全相同，注意，這裡我們並沒有限制時間長度以及滯後，因此，這個假設強到很難出現，所以實務上還是使用弱平穩居多

Note: 

- 弱平穩與強平穩之間並未存在包含關係
- 當聯合分配屬於多元常態時，弱平穩與強平穩等價

### Sample AutoCorrelation Function (ACF)

到這裡，我們已經講完了平穩過程的簡易概念，注意到在弱平穩過程中，我們提到了變數之間的時間關係只與滯後有關，那麼滯後的關係要怎麼衡量呢? 假設我們想知道**某一時間與前面時間的相關性**，例如在隨機遊走的範例中，當前變數與前一時間點的變數有關，當我們得知這一訊息時，就可以****使用差分的技巧將資料分解為弱平穩**。ACF 就可以幫我們做到這一目的

首先，自相關的定義如下

$$
\rho_{\ell}=\frac{\mathrm{cov}(r_{t},r_{t-\ell})}{\mathrm{var}(r_{t})}
$$

其中

- $\gamma_{k}=\operatorname{Cov}(r_{t},r_{t-k})=E[(r_{t}-\mu)(r_{t-k}-\mu)]:$ 表示滯後 $k$ 的自變異
- $\rho_0=1:$ 自己與自己的相關性為 1 
- $\rho_k=\rho_{-k}:$ 表示變數之間的關係只與滯後長度有關

說白了，自相關係數是個衡量變數 Lag-$\ell$ 的相關性方法，上面公式看起來很完美，但是 $\mu$ 基本上是不知道的 (我們不可能知道真實的模型)，因此，實務上我們使用經驗自相關函數

$$
\hat{\rho}_{\ell}=\frac{\Sigma_{t=1}^{T-\ell}(r_{t}-\bar{r})(r_{t+\ell}-\bar{r})}{\Sigma_{t=1}^{T}(r_{t}-\bar{r})^{2}}
$$

其中

- $\bar r:$ 樣本平均
- $T:$ 樣本數量

python 實現很非常方便，我們可以透過 `numpy.correlate` 計算，`numpy.correlate(a, v, mode)` 將 v 作為 filter 掃過 a，類似訊號中的捲機運算，初始時我們會將 v 滾動與 a 對其進行捲機運算 (若大小不一則補零)，而後逐次向右移動。在官網的資訊中，`numpy.correlate` 提供了三種模式

$$
c_k=\sum_n a_{n+k} * \bar v_n
$$

其中 

- $\bar v_n$ 表示 complex conjugation
- `mode:` 捲機運算方式
    - `valid:` v 直接與 a 內積，直到最後一項與 a 最後一項對齊
    - `same:` v 最後一項由左至右內積，直到最後一項與 a 最後一項對齊
    - `full:` v 最後一項由左至右內積，直到第一項與 a 最後一項對齊

```{python}
def acf(series, lag=None):
    """
    Calculate the autocorrelation function (ACF) for a given time series.

    Parameters:
        series (array-like): The time series data.
        lag (int, optional): The maximum lag for which to calculate the ACF.
            If None (default), the ACF is calculated for all possible lags.

    Returns:
        acf_values (array): Autocorrelation values for the given time series.
            If `lag` is provided, returns a single value representing
            autocorrelation at that lag. Otherwise, returns an array of
            autocorrelation values for all lags.
    """
    series = np.asarray(series)
    n = len(series)

    mean = np.mean(series)
    centered_data = series - mean

    # Calculate autocovariance function
    acov = np.correlate(centered_data, centered_data, mode='full')
    acf_values = acov / sum(centered_data ** 2)

    if lag is not None:
        return acf_values[(n-1):(n-1+lag)]
    else:
        return acf_values[(n-1):]
```

接下來我們比較隨機遊走和一階差分的 ACF 圖表

```{python}
#| code-fold: true
rw_acf = acf(walks, lag=90)
title = 'ACF Random Walks'

fig = go.Figure()

fig.add_trace(go.Scatter(x=list(range(T)), y=rw_acf, mode='markers',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

```{python}
#| code-fold: true
d_acf = acf(D, lag=90)
title = 'ACF Random Walks'

fig = go.Figure()

fig.add_trace(go.Scatter(x=list(range(T-1)), y=d_acf, mode='markers',
    name="sin",
    line=dict(color="blue", width=1),
    connectgaps=True,
))
fig.update_layout(title=title)
fig.show()
```

可以看到在差分完成之後，資料中就基本不存在什麼相關性了

另外，我們也可以透過 python 套件 `statsmodels.graphics.tsaplots.plot_acf` 直接完成，如下

```{python}
from statsmodels.graphics.tsaplots import plot_acf
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

plot_acf(walks, lags=90)
plt.show()

plot_acf(D, lags=90)
plt.show()
```