[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Time Series Note",
    "section": "",
    "text": "序言\n本書謹收錄平時我上課的筆記，在本書中，我盡量少用些數學符號來解釋時間序列的公式，比起直接使用公式，我更傾向直觀的理解一個概念。\n本書將使用 python 時做時間序列的相關資料，你可以在每個時間序列的概念下看到簡易的 python 代碼，基本上，除了特別麻煩的公式，我都直接提供最原始的程式碼，這樣比較助於我們理解底層的運算邏輯，至於視覺化方面，我採用了 python 套件 plotly 來完成，由於他的底層運算是基於 d3.js，因此可以做到使用者互動，這也是我選擇 plotly 的原因"
  },
  {
    "objectID": "ts_intro.html#time-series-v.s.-cross-sectional",
    "href": "ts_intro.html#time-series-v.s.-cross-sectional",
    "title": "1  什麼是時間序列",
    "section": "1.1 Time Series v.s. Cross Sectional",
    "text": "1.1 Time Series v.s. Cross Sectional\n最常被混淆的概念就是時間序列 (time series) 與橫斷面 (cross sectional) 資料，他們的差別如下\n\nTime Series v.s. Cross Sectional\n\n\n\n\n\n\n\n差別\nTime Series\nCross Sectional\n\n\n\n\n定義\n固定時間點蒐集的序列資料\n同一時間點不同個體的資料\n\n\n範例\n2000/01/01 到 2020/01/01 台積電每日股票的收盤價\n2000/01/01 台灣前 50 大上市公司的股價"
  },
  {
    "objectID": "ts_intro.html#為什麼我們需要時間序列模型",
    "href": "ts_intro.html#為什麼我們需要時間序列模型",
    "title": "1  什麼是時間序列",
    "section": "1.2 為什麼我們需要時間序列模型",
    "text": "1.2 為什麼我們需要時間序列模型\n接續前文的定義，假設我們想調查 2000/01/01 到 2020/01/01 台積電每日股票的收盤價，每天收盤價對於我們而言都是一個隨機變數，而且我們不能保證這些隨機變數屬於同一個分配，因為他們來自不同時間點，換句話說，每天的收盤價是從不同母體抽樣出來的，而且只有一個樣本點，當只有一個樣本點時，就不能採用過往我們熟悉的統計工具解決問題，因此，我們勢必要假設資料與資料之間存在某種的關係，而這個關係是會隨著時間變化的"
  },
  {
    "objectID": "ts_intro.html#數學上的時間序列",
    "href": "ts_intro.html#數學上的時間序列",
    "title": "1  什麼是時間序列",
    "section": "1.3 數學上的時間序列",
    "text": "1.3 數學上的時間序列\n我們假設隨機變數\n\n\\({U}_t, t\\in \\{1,\\cdots,T\\}\\)\n\n表示時間序列的隨機變數。我們可以把 \\(U_t\\) 看做是隨著時間變化的變數，例如每日股價，每年人口增長率等等，總結來說 \\(U_t\\) 包含兩個面向\n\n隨機變數 \\(U \\to\\) 表示隨著時間變化我們感興趣的指標\n時間區間 \\(t \\to\\) 表示時間的過程，通常為等量區間，例如每天、每年\n\n至此，我們已經大致了解時間序列是什麼樣的資料了，但是，事實上並不是這麼簡單，我們常常看到的時間序列表現形式通常會長的像下面這樣\n\\(U_t=T_t+S_t+C_t+R_t\\)\n其中\n\n\\(T_t:\\) 趨勢效應 (Trend component)\n\\(S_t:\\) 季節效應 (Seasonal component)\n\\(C_t:\\) 循環效應 (Cyclical component)\n\\(R_t:\\) 隨機效應 (Random component)\n\n時間序列資料大概可以分解成上面的四個主要部分，接下來我們來一一解析他們\n\n1.3.1 趨勢效應\n我們常常說一檔股票有上升趨勢或下降趨勢，其實很容易理解，趨勢表示長期時間來看，資料平移變化的方向。例如在下面的例子中，我們調查一般民眾獲取新聞的方式，可以很明顯看到\n\nDownward Trend: Television、Newspaper\nNo Trend: Radio\nUpward Trand: Internet\n\n表示隨著時間發展，使用網路獲取信息的人們越來越多了\n\n\nCode\ntitle = 'Main Source for News'\nlabels = ['Television', 'Newspaper', 'Internet', 'Radio']\ncolors = ['rgb(67,67,67)', 'rgb(115,115,115)', 'rgb(49,130,189)', 'rgb(189,189,189)']\n\nmode_size = [8, 8, 12, 8]\nline_size = [2, 2, 4, 2]\n\nx_data = np.vstack((np.arange(2001, 2014),)*4)\n\ny_data = np.array([\n    [74, 82, 80, 74, 73, 72, 74, 70, 70, 66, 66, 69],\n    [45, 42, 50, 46, 36, 36, 34, 35, 32, 31, 31, 28],\n    [13, 14, 20, 24, 20, 24, 24, 40, 35, 41, 43, 50],\n    [18, 21, 18, 21, 16, 14, 13, 18, 17, 16, 19, 23],\n])\n\nfig = go.Figure()\n\nfor i in range(0, 4):\n    fig.add_trace(go.Scatter(x=x_data[i], y=y_data[i], mode='lines',\n        name=labels[i],\n        line=dict(color=colors[i], width=line_size[i]),\n        connectgaps=True,\n    ))\n\n    # endpoints\n    fig.add_trace(go.Scatter(\n        x=[x_data[i][0], x_data[i][-1]],\n        y=[y_data[i][0], y_data[i][-1]],\n        mode='markers',\n        marker=dict(color=colors[i], size=mode_size[i])\n    ))\n\nfig.update_layout(\n    xaxis=dict(\n        showline=True,\n        showgrid=False,\n        showticklabels=True,\n        linecolor='rgb(204, 204, 204)',\n        linewidth=2,\n        ticks='outside',\n        tickfont=dict(\n            family='Arial',\n            size=12,\n            color='rgb(82, 82, 82)',\n        ),\n    ),\n    yaxis=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    autosize=False,\n    margin=dict(\n        autoexpand=False,\n        l=100,\n        r=20,\n        t=110,\n    ),\n    showlegend=False,\n    plot_bgcolor='white'\n)\n\nannotations = []\n\n# Adding labels\nfor y_trace, label, color in zip(y_data, labels, colors):\n    # labeling the left_side of the plot\n    annotations.append(dict(xref='paper', x=0.05, y=y_trace[0],\n                                  xanchor='right', yanchor='middle',\n                                  text=label + ' {}%'.format(y_trace[0]),\n                                  font=dict(family='Arial',\n                                            size=16),\n                                  showarrow=False))\n    # labeling the right_side of the plot\n    annotations.append(dict(xref='paper', x=0.95, y=y_trace[11],\n                                  xanchor='left', yanchor='middle',\n                                  text='{}%'.format(y_trace[11]),\n                                  font=dict(family='Arial',\n                                            size=16),\n                                  showarrow=False))\n# Title\nannotations.append(dict(xref='paper', yref='paper', x=0.0, y=1.05,\n                              xanchor='left', yanchor='bottom',\n                              text='Main Source for News',\n                              font=dict(family='Arial',\n                                        size=30,\n                                        color='rgb(37,37,37)'),\n                              showarrow=False))\n# Source\nannotations.append(dict(xref='paper', yref='paper', x=0.5, y=-0.1,\n                              xanchor='center', yanchor='top',\n                              text='Source: PewResearch Center & ' +\n                                   'Storytelling with data',\n                              font=dict(family='Arial',\n                                        size=12,\n                                        color='rgb(150,150,150)'),\n                              showarrow=False))\n\nfig.update_layout(annotations=annotations)\n\nfig.show()\n\n\n\n                                                \n\n\n\n\n1.3.2 季節效應與循環效應\n季節效應與週期效應都是週期性產生的影響，但大家較易於混淆這兩者的概念，簡單來說，如果頻率變化固定且已知，則為季節性，例如氣溫的變化會隨著四季更迭，降雨量也會根據不同月份而不同，若頻率變化不固定，則為循環性\n例如下面這個範例有週期性的特徵，且每個同樣的時間區間就會有相同的頻率，則為季節性\n\n\nCode\ntitle = 'Seasonal Effect'\n\nx_data = np.linspace(-10, 10, 100)\n\ny_data = np.array(\n    np.sin(x_data) + np.random.normal(size=x_data.shape) * 0.25\n)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n下面這張圖雖然具有週期性特徵，但是其頻率不固定，雖然固定的一個時間區間會產生高峰，但是高峰會隨著時間越來越高\n\n\nCode\ntitle = 'Cyclical Effect'\n\nx_data = np.linspace(-10, 10, 100)\n\ny_data = np.array(\n    np.sin(x_data)*np.exp(x_data/10) + np.random.normal(size=x_data.shape) * 0.25\n)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n\n\n1.3.3 隨機效應\n最後一個為隨機效應，通常表示資料的隨機性，也最好理解，因為她就是隨著時間產生的一個隨機效應\n例如下面這張圖，雖然我們是使用 sin 函數去生成的，但是我們給他加上一個常態分配的隨機抽樣，整體就變得不是那麼明顯了\n\n\nCode\ntitle = 'Seasonal Effect'\n\nx_data = np.linspace(-10, 10, 100)\n\ny_data = np.array(\n    np.sin(x_data) + np.random.normal(size=x_data.shape) * 1\n)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines+markers',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()"
  },
  {
    "objectID": "ts_intro.html#我怎麼知道資料是否適合時間序列分析",
    "href": "ts_intro.html#我怎麼知道資料是否適合時間序列分析",
    "title": "1  什麼是時間序列",
    "section": "1.4 我怎麼知道資料是否適合時間序列分析",
    "text": "1.4 我怎麼知道資料是否適合時間序列分析\n如何知道資料屬於哪一種效應是一種非常仰賴經驗判斷的方法，例如從下面這張圖來說，我們幾乎無法斷定資料是否存在某種效應，最多也只能說是沒有一個明顯的趨勢效應\n\n\nCode\ntitle = 'Cyclical Effect'\n\nx_data = np.linspace(-10, 10, 1000)\n\ny_data = np.array(\n    np.sin(x_data)*np.exp(x_data/100)/10 + np.random.normal(size=x_data.shape)\n)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=x_data, y=y_data, mode='lines',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n從最初到現在，我們也可以看出，我們對於資料存在著多種假設，我們基於這些假設去判斷資料最可能的模型，然而，當有一些模型假設錯誤時，很長造成模型擬合效果不彰，因此，對於資料使用時間序列模型是最後的手段，最好還是先嘗試其他模型\n讓我們回到上面的那筆資料，當我們暫時忽略時間的效應，按照資料的隨機變數畫出下面的分布圖時，我們會發現它其實很像是一個常態分配，但好像又比常態分配寬一點，這讓我們懷疑到底時間有沒有存在影響，又或是他的影響到底多大。所以接下來，我們來講講怎麼看待這件事情\n\nimport plotly.figure_factory as ff\nimport numpy as np\n\nhist_data = [y_data]\n\ngroup_labels = ['Data (no T)']\ncolors = ['#A56CC1']\n\n# Create distplot with curve_type set to 'normal'\nfig = ff.create_distplot(hist_data, group_labels, colors=colors,\n                         bin_size=.2, show_rug=False)\n\n# Add title\nfig.update_layout(title_text='Hist and Curve Plot')\nfig.show()"
  },
  {
    "objectID": "ts_intro.html#平穩性-stationary",
    "href": "ts_intro.html#平穩性-stationary",
    "title": "1  什麼是時間序列",
    "section": "1.5 平穩性 Stationary",
    "text": "1.5 平穩性 Stationary\n在時間序列分析中，我們必須對於資料有簡單又合理的假設，才可以容易建立模型，平穩性就是其中一個，簡單來說，平穩性表示你的資料還是有時間效應，但是這個效應影響不大，其主要分為兩種\n\n1.5.1 弱平穩 Weak stationary\n我們先來看看弱平穩的數學定義\n若 \\(\\{Z_t\\}\\) 被稱為弱 (second-order or covariance stationary) 平穩過程，則\n\n\\(\\mu(t)=C:\\) \\(\\mu\\) 與時間無關\n\\(\\gamma(t, t-k)=\\gamma(0, k):\\) 共變異函數只與滯後 (lag) 有關\n\n簡單而言，平均變化與時間無關，且變數之間的相關性只在滯後上有關係。例如，白噪聲就是一個弱平穩過程，因為白噪聲 \\(\\sim \\mathcal{N}(0,\\sigma^2I)\\)。隨機遊走是非平穩的，例如下面我們建立一個例子\n\\[\nX_t = X_{t-1} + \\epsilon\n\\]\n其中 \\(\\epsilon\\) 為白噪聲，則我們有\n\n\\(\\mathbb{E}(X_t)=\\mathbb{E}(X_{t-1})\\)\n\\(\\mbox{Var}(X_t)=t\\sigma^2\\)\n\n\n\nCode\ntitle = 'Seasonal Effect'\n\nT = 1000\nwalks = []\n\nloc = 0\nfor i in range(T):\n    loc += + np.random.normal(0,1)\n    walks.append(loc)\nwalks = np.array(walks)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=list(range(T)), y=walks, mode='lines',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n因為變異數與時間有關，因此不是弱平穩，但是當我們去檢驗差分 \\(D_t=X_t-X_{t-1}=ㄔ\\) 的分布時，他又是弱平穩的，因為\n\n\\(\\mathbb{E}(D_t)=0\\)\n\\(\\mbox{Var}(X_t)=\\sigma^2\\)\n\n下面我們畫圖來值觀感受一下差分的魅力\n\n\nCode\ntitle = 'Seasonal Effect'\n\nD = walks[1:] - walks[:-1]\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=list(range(T-1)), y=D, mode='lines',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n是不是完全變成白噪聲了啊，所以我們會發現，很多時間序列的方法都使用差分的技巧來將原先的資料分解到平穩狀態\n\n\n1.5.2 強平穩 Strict stationary\n接著，我們介紹另外一種平穩過程，強平穩，他的數學定義如下\n若 \\(\\{Z_t\\}\\) 被稱為強平穩過程，則\n\\(Z_{t_1}, Z_{t_2}, \\cdots, Z_{t_n}\\) 的聯合分配與 \\(Z_{t_1-k}, Z_{t_2-k}, \\cdots, Z_{t_n-k}\\) 的聯合分配相同\n講白話一點，就是我們選一個時間序列的某一段切下去，跟前面的一段時間完全相同，注意，這裡我們並沒有限制時間長度以及滯後，因此，這個假設強到很難出現，所以實務上還是使用弱平穩居多\nNote:\n\n弱平穩與強平穩之間並未存在包含關係\n當聯合分配屬於多元常態時，弱平穩與強平穩等價\n\n\n\n1.5.3 Sample AutoCorrelation Function (ACF)\n到這裡，我們已經講完了平穩過程的簡易概念，注意到在弱平穩過程中，我們提到了變數之間的時間關係只與滯後有關，那麼滯後的關係要怎麼衡量呢? 假設我們想知道某一時間與前面時間的相關性，例如在隨機遊走的範例中，當前變數與前一時間點的變數有關，當我們得知這一訊息時，就可以****使用差分的技巧將資料分解為弱平穩**。ACF 就可以幫我們做到這一目的\n首先，自相關的定義如下\n\\[\n\\rho_{\\ell}=\\frac{\\mathrm{cov}(r_{t},r_{t-\\ell})}{\\mathrm{var}(r_{t})}\n\\]\n其中\n\n\\(\\gamma_{k}=\\operatorname{Cov}(r_{t},r_{t-k})=E[(r_{t}-\\mu)(r_{t-k}-\\mu)]:\\) 表示滯後 \\(k\\) 的自變異\n\\(\\rho_0=1:\\) 自己與自己的相關性為 1\n\\(\\rho_k=\\rho_{-k}:\\) 表示變數之間的關係只與滯後長度有關\n\n說白了，自相關係數是個衡量變數 Lag-\\(\\ell\\) 的相關性方法，上面公式看起來很完美，但是 \\(\\mu\\) 基本上是不知道的 (我們不可能知道真實的模型)，因此，實務上我們使用經驗自相關函數\n\\[\n\\hat{\\rho}_{\\ell}=\\frac{\\Sigma_{t=1}^{T-\\ell}(r_{t}-\\bar{r})(r_{t+\\ell}-\\bar{r})}{\\Sigma_{t=1}^{T}(r_{t}-\\bar{r})^{2}}\n\\]\n其中\n\n\\(\\bar r:\\) 樣本平均\n\\(T:\\) 樣本數量\n\npython 實現很非常方便，我們可以透過 numpy.correlate 計算，numpy.correlate(a, v, mode) 將 v 作為 filter 掃過 a，類似訊號中的捲機運算，初始時我們會將 v 滾動與 a 對其進行捲機運算 (若大小不一則補零)，而後逐次向右移動。在官網的資訊中，numpy.correlate 提供了三種模式\n\\[\nc_k=\\sum_n a_{n+k} * \\bar v_n\n\\]\n其中\n\n\\(\\bar v_n\\) 表示 complex conjugation\nmode: 捲機運算方式\n\nvalid: v 直接與 a 內積，直到最後一項與 a 最後一項對齊\nsame: v 最後一項由左至右內積，直到最後一項與 a 最後一項對齊\nfull: v 最後一項由左至右內積，直到第一項與 a 最後一項對齊\n\n\n\ndef acf(series, lag=None):\n    \"\"\"\n    Calculate the autocorrelation function (ACF) for a given time series.\n\n    Parameters:\n        series (array-like): The time series data.\n        lag (int, optional): The maximum lag for which to calculate the ACF.\n            If None (default), the ACF is calculated for all possible lags.\n\n    Returns:\n        acf_values (array): Autocorrelation values for the given time series.\n            If `lag` is provided, returns a single value representing\n            autocorrelation at that lag. Otherwise, returns an array of\n            autocorrelation values for all lags.\n    \"\"\"\n    series = np.asarray(series)\n    n = len(series)\n\n    mean = np.mean(series)\n    centered_data = series - mean\n\n    # Calculate autocovariance function\n    acov = np.correlate(centered_data, centered_data, mode='full')\n    acf_values = acov / sum(centered_data ** 2)\n\n    if lag is not None:\n        return acf_values[(n-1):(n-1+lag)]\n    else:\n        return acf_values[(n-1):]\n\n接下來我們比較隨機遊走和一階差分的 ACF 圖表\n\n\nCode\nrw_acf = acf(walks, lag=90)\ntitle = 'ACF Random Walks'\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=list(range(T)), y=rw_acf, mode='markers',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n\n\nCode\nd_acf = acf(D, lag=90)\ntitle = 'ACF Random Walks'\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=list(range(T-1)), y=d_acf, mode='markers',\n    name=\"sin\",\n    line=dict(color=\"blue\", width=1),\n    connectgaps=True,\n))\nfig.update_layout(title=title)\nfig.show()\n\n\n\n                                                \n\n\n可以看到在差分完成之後，資料中就基本不存在什麼相關性了\n另外，我們也可以透過 python 套件 statsmodels.graphics.tsaplots.plot_acf 直接完成，如下\n\nfrom statsmodels.graphics.tsaplots import plot_acf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nplot_acf(walks, lags=90)\nplt.show()\n\nplot_acf(D, lags=90)\nplt.show()"
  }
]